// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using global::System.Runtime.Versioning;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32
{
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_32
	{
		private const int SpanLength = 32;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_32(string value) => value.AsSpan();
		public static implicit operator __char_32(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_32 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_260
	{
		private const int SpanLength = 260;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_260(string value) => value.AsSpan();
		public static implicit operator __char_260(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_260 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	namespace Foundation
	{
		internal partial struct __CHAR_260
		{
			private const int SpanLength = 260;

			/// <summary>The length of the inline array.</summary>
			internal readonly int Length => SpanLength;
			internal winmdroot.Foundation.CHAR _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72,_73,_74,_75,_76,_77,_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102,_103,_104,_105,_106,_107,_108,_109,_110,_111,_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127,_128,_129,_130,_131,_132,_133,_134,_135,_136,_137,_138,_139,_140,_141,_142,_143,_144,_145,_146,_147,_148,_149,_150,_151,_152,_153,_154,_155,_156,_157,_158,_159,_160,_161,_162,_163,_164,_165,_166,_167,_168,_169,_170,_171,_172,_173,_174,_175,_176,_177,_178,_179,_180,_181,_182,_183,_184,_185,_186,_187,_188,_189,_190,_191,_192,_193,_194,_195,_196,_197,_198,_199,_200,_201,_202,_203,_204,_205,_206,_207,_208,_209,_210,_211,_212,_213,_214,_215,_216,_217,_218,_219,_220,_221,_222,_223,_224,_225,_226,_227,_228,_229,_230,_231,_232,_233,_234,_235,_236,_237,_238,_239,_240,_241,_242,_243,_244,_245,_246,_247,_248,_249,_250,_251,_252,_253,_254,_255,_256,_257,_258,_259;

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe Span<winmdroot.Foundation.CHAR> AsSpan() => MemoryMarshal.CreateSpan(ref _0, SpanLength);

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe readonly ReadOnlySpan<winmdroot.Foundation.CHAR> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(_0), SpanLength);
			public static implicit operator __CHAR_260(ReadOnlySpan<winmdroot.Foundation.CHAR> value)
			{
				Unsafe.SkipInit(out __CHAR_260 result);
				value.CopyTo(result.AsSpan());
				int initLength = value.Length;
				result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
				return result;
			}
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_256
	{
		private const int SpanLength = 256;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_256(string value) => value.AsSpan();
		public static implicit operator __char_256(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_256 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	namespace Foundation
	{
		internal partial struct __CHAR_256
		{
			private const int SpanLength = 256;

			/// <summary>The length of the inline array.</summary>
			internal readonly int Length => SpanLength;
			internal winmdroot.Foundation.CHAR _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72,_73,_74,_75,_76,_77,_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102,_103,_104,_105,_106,_107,_108,_109,_110,_111,_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127,_128,_129,_130,_131,_132,_133,_134,_135,_136,_137,_138,_139,_140,_141,_142,_143,_144,_145,_146,_147,_148,_149,_150,_151,_152,_153,_154,_155,_156,_157,_158,_159,_160,_161,_162,_163,_164,_165,_166,_167,_168,_169,_170,_171,_172,_173,_174,_175,_176,_177,_178,_179,_180,_181,_182,_183,_184,_185,_186,_187,_188,_189,_190,_191,_192,_193,_194,_195,_196,_197,_198,_199,_200,_201,_202,_203,_204,_205,_206,_207,_208,_209,_210,_211,_212,_213,_214,_215,_216,_217,_218,_219,_220,_221,_222,_223,_224,_225,_226,_227,_228,_229,_230,_231,_232,_233,_234,_235,_236,_237,_238,_239,_240,_241,_242,_243,_244,_245,_246,_247,_248,_249,_250,_251,_252,_253,_254,_255;

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe Span<winmdroot.Foundation.CHAR> AsSpan() => MemoryMarshal.CreateSpan(ref _0, SpanLength);

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe readonly ReadOnlySpan<winmdroot.Foundation.CHAR> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(_0), SpanLength);
			public static implicit operator __CHAR_256(ReadOnlySpan<winmdroot.Foundation.CHAR> value)
			{
				Unsafe.SkipInit(out __CHAR_256 result);
				value.CopyTo(result.AsSpan());
				int initLength = value.Length;
				result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
				return result;
			}
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_128
	{
		private const int SpanLength = 128;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_128(string value) => value.AsSpan();
		public static implicit operator __char_128(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_128 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_1
	{
		private const int SpanLength = 1;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_1(string value) => value.AsSpan();
		public static implicit operator __char_1(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_1 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_14
	{
		private const int SpanLength = 14;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_14(string value) => value.AsSpan();
		public static implicit operator __char_14(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_14 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	namespace Foundation
	{
		internal partial struct __CHAR_128
		{
			private const int SpanLength = 128;

			/// <summary>The length of the inline array.</summary>
			internal readonly int Length => SpanLength;
			internal winmdroot.Foundation.CHAR _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72,_73,_74,_75,_76,_77,_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102,_103,_104,_105,_106,_107,_108,_109,_110,_111,_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127;

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe Span<winmdroot.Foundation.CHAR> AsSpan() => MemoryMarshal.CreateSpan(ref _0, SpanLength);

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe readonly ReadOnlySpan<winmdroot.Foundation.CHAR> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(_0), SpanLength);
			public static implicit operator __CHAR_128(ReadOnlySpan<winmdroot.Foundation.CHAR> value)
			{
				Unsafe.SkipInit(out __CHAR_128 result);
				value.CopyTo(result.AsSpan());
				int initLength = value.Length;
				result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
				return result;
			}
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_50
	{
		private const int SpanLength = 50;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_50(string value) => value.AsSpan();
		public static implicit operator __char_50(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_50 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_80
	{
		private const int SpanLength = 80;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_80(string value) => value.AsSpan();
		public static implicit operator __char_80(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_80 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_30
	{
		private const int SpanLength = 30;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_30(string value) => value.AsSpan();
		public static implicit operator __char_30(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_30 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal partial struct __char_520
	{
		private const int SpanLength = 520;

		/// <summary>The length of the inline array.</summary>
		internal readonly int Length => SpanLength;
		internal unsafe fixed char Value[SpanLength];

		/// <summary>
		/// Gets a ref to an individual element of the inline array.
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
		/// </summary>
		[UnscopedRef]
		internal unsafe ref char this[int index] => ref Value[index];

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

		/// <summary>
		/// Gets this inline array as a span.
		/// </summary>
		/// <remarks>
		/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
		/// </remarks>
		[UnscopedRef]
		internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

		internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

		internal readonly bool Equals(string value) => Equals(value.AsSpan());

		/// <summary>
		/// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">
		/// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
		/// </exception>
		internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

		/// <summary>
		/// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
		/// </summary>
		public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
		public static implicit operator __char_520(string value) => value.AsSpan();
		public static implicit operator __char_520(ReadOnlySpan<char> value)
		{
			Unsafe.SkipInit(out __char_520 result);
			value.CopyTo(result.AsSpan());
			int initLength = value.Length;
			result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
			return result;
		}
	}

	namespace Foundation
	{
		internal partial struct __CHAR_129
		{
			private const int SpanLength = 129;

			/// <summary>The length of the inline array.</summary>
			internal readonly int Length => SpanLength;
			internal winmdroot.Foundation.CHAR _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72,_73,_74,_75,_76,_77,_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102,_103,_104,_105,_106,_107,_108,_109,_110,_111,_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127,_128;

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe Span<winmdroot.Foundation.CHAR> AsSpan() => MemoryMarshal.CreateSpan(ref _0, SpanLength);

			/// <summary>
			/// Gets this inline array as a span.
			/// </summary>
			/// <remarks>
			/// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
			/// </remarks>
			[UnscopedRef]
			internal unsafe readonly ReadOnlySpan<winmdroot.Foundation.CHAR> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(_0), SpanLength);
			public static implicit operator __CHAR_129(ReadOnlySpan<winmdroot.Foundation.CHAR> value)
			{
				Unsafe.SkipInit(out __CHAR_129 result);
				value.CopyTo(result.AsSpan());
				int initLength = value.Length;
				result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
				return result;
			}
		}
	}
}
