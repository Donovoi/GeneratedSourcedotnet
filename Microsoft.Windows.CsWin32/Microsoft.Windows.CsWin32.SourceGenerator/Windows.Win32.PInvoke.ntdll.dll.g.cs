// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using global::System.Runtime.Versioning;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32
{

	/// <content>
	/// Contains extern methods from "ntdll.dll".
	/// </content>
	internal static partial class PInvoke
	{
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlCrc32(void* Buffer, nuint Size, uint InitialCrc);

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe ulong RtlCrc64(void* Buffer, nuint Size, ulong InitialCrc);

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOLEAN RtlIsZeroMemory(void* Buffer, nuint Length);

		/// <inheritdoc cref="RtlGetProductInfo(uint, uint, uint, uint, uint*)"/>
		internal static unsafe winmdroot.Foundation.BOOLEAN RtlGetProductInfo(uint OSMajorVersion, uint OSMinorVersion, uint SpMajorVersion, uint SpMinorVersion, out uint ReturnedProductType)
		{
			fixed (uint* ReturnedProductTypeLocal = &ReturnedProductType)
			{
				winmdroot.Foundation.BOOLEAN __result = PInvoke.RtlGetProductInfo(OSMajorVersion, OSMinorVersion, SpMajorVersion, SpMinorVersion, ReturnedProductTypeLocal);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOLEAN RtlGetProductInfo(uint OSMajorVersion, uint OSMinorVersion, uint SpMajorVersion, uint SpMinorVersion, uint* ReturnedProductType);

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern winmdroot.System.SystemInformation.OS_DEPLOYEMENT_STATE_VALUES RtlOsDeploymentState(uint Flags);

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe void RtlGetDeviceFamilyInfoEnum([Optional] ulong* pullUAPInfo, [Optional] winmdroot.System.SystemInformation.DEVICEFAMILYINFOENUM* pulDeviceFamily, [Optional] winmdroot.System.SystemInformation.DEVICEFAMILYDEVICEFORM* pulDeviceForm);

		/// <inheritdoc cref="RtlConvertDeviceFamilyInfoToString(uint*, uint*, winmdroot.Foundation.PWSTR, winmdroot.Foundation.PWSTR)"/>
		internal static unsafe uint RtlConvertDeviceFamilyInfoToString(ref uint pulDeviceFamilyBufferSize, ref uint pulDeviceFormBufferSize, winmdroot.Foundation.PWSTR DeviceFamily, winmdroot.Foundation.PWSTR DeviceForm)
		{
			fixed (uint* pulDeviceFormBufferSizeLocal = &pulDeviceFormBufferSize)
			{
				fixed (uint* pulDeviceFamilyBufferSizeLocal = &pulDeviceFamilyBufferSize)
				{
					uint __result = PInvoke.RtlConvertDeviceFamilyInfoToString(pulDeviceFamilyBufferSizeLocal, pulDeviceFormBufferSizeLocal, DeviceFamily, DeviceForm);
					return __result;
				}
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlConvertDeviceFamilyInfoToString(uint* pulDeviceFamilyBufferSize, uint* pulDeviceFormBufferSize, winmdroot.Foundation.PWSTR DeviceFamily, winmdroot.Foundation.PWSTR DeviceForm);

		/// <inheritdoc cref="RtlSwitchedVVI(winmdroot.System.SystemInformation.OSVERSIONINFOEXW*, uint, ulong)"/>
		internal static unsafe uint RtlSwitchedVVI(in winmdroot.System.SystemInformation.OSVERSIONINFOEXW VersionInfo, uint TypeMask, ulong ConditionMask)
		{
			fixed (winmdroot.System.SystemInformation.OSVERSIONINFOEXW* VersionInfoLocal = &VersionInfo)
			{
				uint __result = PInvoke.RtlSwitchedVVI(VersionInfoLocal, TypeMask, ConditionMask);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlSwitchedVVI(winmdroot.System.SystemInformation.OSVERSIONINFOEXW* VersionInfo, uint TypeMask, ulong ConditionMask);

		/// <inheritdoc cref="NtQueryInformationProcess(winmdroot.Foundation.HANDLE, winmdroot.System.Threading.PROCESSINFOCLASS, void*, uint, uint*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtQueryInformationProcess(SafeHandle ProcessHandle, winmdroot.System.Threading.PROCESSINFOCLASS ProcessInformationClass, void* ProcessInformation, uint ProcessInformationLength, ref uint ReturnLength)
		{
			bool ProcessHandleAddRef = false;
			try
			{
				fixed (uint* ReturnLengthLocal = &ReturnLength)
				{
					winmdroot.Foundation.HANDLE ProcessHandleLocal;
					if (ProcessHandle is object)
					{
						ProcessHandle.DangerousAddRef(ref ProcessHandleAddRef);
						ProcessHandleLocal = (winmdroot.Foundation.HANDLE)ProcessHandle.DangerousGetHandle();
					}
					else
						ProcessHandleLocal = default(winmdroot.Foundation.HANDLE);
					winmdroot.Foundation.NTSTATUS __result = PInvoke.NtQueryInformationProcess(ProcessHandleLocal, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLengthLocal);
					return __result;
				}
			}
			finally
			{
				if (ProcessHandleAddRef)
					ProcessHandle.DangerousRelease();
			}
		}

		/// <summary>Retrieves information about the specified process.</summary>
		/// <param name="ProcessHandle">A handle to the process for which information is to be retrieved.</param>
		/// <param name="ProcessInformationClass"></param>
		/// <param name="ProcessInformation">A pointer to a buffer supplied by the calling application into which the function writes the requested information. The size of the information written varies depending on the data type of the <i>ProcessInformationClass</i> parameter:</param>
		/// <param name="ProcessInformationLength">The size of the buffer pointed to by the <i>ProcessInformation</i> parameter, in bytes.</param>
		/// <param name="ReturnLength">A pointer to a variable in which the function returns the size of the requested information. If the function was successful, this is the size of the information written to the buffer pointed to by the <i>ProcessInformation</i> parameter, but if the buffer was too small, this is the minimum size of buffer needed to receive the information successfully.</param>
		/// <returns>
		/// <para>The function returns  an NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are listed in the Ntstatus.h header file available in the DDK, and are described in the DDK documentation under Kernel-Mode Driver Architecture / Design Guide / Driver Programming Techniques / Logging Errors.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntqueryinformationprocess">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtQueryInformationProcess(winmdroot.Foundation.HANDLE ProcessHandle, winmdroot.System.Threading.PROCESSINFOCLASS ProcessInformationClass, void* ProcessInformation, uint ProcessInformationLength, uint* ReturnLength);

		/// <inheritdoc cref="NtQueryInformationThread(winmdroot.Foundation.HANDLE, winmdroot.System.Threading.THREADINFOCLASS, void*, uint, uint*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtQueryInformationThread(SafeHandle ThreadHandle, winmdroot.System.Threading.THREADINFOCLASS ThreadInformationClass, void* ThreadInformation, uint ThreadInformationLength, ref uint ReturnLength)
		{
			bool ThreadHandleAddRef = false;
			try
			{
				fixed (uint* ReturnLengthLocal = &ReturnLength)
				{
					winmdroot.Foundation.HANDLE ThreadHandleLocal;
					if (ThreadHandle is object)
					{
						ThreadHandle.DangerousAddRef(ref ThreadHandleAddRef);
						ThreadHandleLocal = (winmdroot.Foundation.HANDLE)ThreadHandle.DangerousGetHandle();
					}
					else
						ThreadHandleLocal = default(winmdroot.Foundation.HANDLE);
					winmdroot.Foundation.NTSTATUS __result = PInvoke.NtQueryInformationThread(ThreadHandleLocal, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLengthLocal);
					return __result;
				}
			}
			finally
			{
				if (ThreadHandleAddRef)
					ThreadHandle.DangerousRelease();
			}
		}

		/// <summary>Retrieves information about the specified thread.</summary>
		/// <param name="ThreadHandle">A handle to the thread about which information is being requested.</param>
		/// <param name="ThreadInformationClass">
		/// <para>If this parameter is the <b>ThreadIsIoPending</b> value of the  <b>THREADINFOCLASS</b> enumeration, the function determines whether the thread has any I/O operations pending. Use the public  function <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getthreadiopendingflag">GetThreadIOPendingFlag</a> instead to obtain this information. If this parameter is the <b>ThreadQuerySetWin32StartAddress</b> value of the <b>THREADINFOCLASS</b> enumeration, the function returns the start address of the thread. Note that on versions of Windows prior to Windows Vista, the returned start address is only reliable before the thread starts running. If this parameter is the <b>ThreadSubsystemInformation</b> value of the  <b>THREADINFOCLASS</b> enumeration, the function retrieves a <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/ntddk/ne-ntddk-_subsystem_information_type">SUBSYSTEM_INFORMATION_TYPE</a> value indicating the subsystem type of the thread. The buffer pointed to by the <i>ThreadInformation</i> parameter should be large enough to hold a single <b>SUBSYSTEM_INFORMATION_TYPE</b> enumeration.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntqueryinformationthread#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="ThreadInformation">
		/// <para>A pointer to a buffer in which the function writes the requested information. If <b>ThreadIsIoPending</b> is specified for the <i>ThreadInformationClass</i> parameter, this buffer must be large enough to hold a <b>ULONG</b> value, which indicates whether  the specified thread has I/O requests pending. If this value is equal to zero, then there are no I/O operations pending; otherwise, if the value is nonzero, then the thread does have I/O operations pending. Use the public  function <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getthreadiopendingflag">GetThreadIOPendingFlag</a> instead to obtain this information. If <b>ThreadQuerySetWin32StartAddress</b> is specified for the <i>ThreadInformationClass</i> parameter, this buffer must be large enough to hold a PVOID value, which is the start address of the thread.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntqueryinformationthread#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="ThreadInformationLength">The size of the buffer pointed to by the <i>ThreadInformation</i> parameter, in bytes.</param>
		/// <param name="ReturnLength">A pointer to a variable in which the function returns the size of the requested information. If the function was successful, this is the size of the information written to the buffer pointed to by the <i>ThreadInformation</i> parameter, but if the buffer was too small, this is the minimum size of buffer required to receive the information successfully.</param>
		/// <returns>
		/// <para>Returns an NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are listed in the Ntstatus.h header file available in the DDK, and are described in the DDK documentation under Kernel-Mode Driver Architecture / Design Guide / Driver Programming Techniques / Logging Errors.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntqueryinformationthread">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtQueryInformationThread(winmdroot.Foundation.HANDLE ThreadHandle, winmdroot.System.Threading.THREADINFOCLASS ThreadInformationClass, void* ThreadInformation, uint ThreadInformationLength, uint* ReturnLength);

		/// <inheritdoc cref="NtSetInformationThread(winmdroot.Foundation.HANDLE, winmdroot.System.Threading.THREADINFOCLASS, void*, uint)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtSetInformationThread(SafeHandle ThreadHandle, winmdroot.System.Threading.THREADINFOCLASS ThreadInformationClass, void* ThreadInformation, uint ThreadInformationLength)
		{
			bool ThreadHandleAddRef = false;
			try
			{
				winmdroot.Foundation.HANDLE ThreadHandleLocal;
				if (ThreadHandle is object)
				{
					ThreadHandle.DangerousAddRef(ref ThreadHandleAddRef);
					ThreadHandleLocal = (winmdroot.Foundation.HANDLE)ThreadHandle.DangerousGetHandle();
				}
				else
					ThreadHandleLocal = default(winmdroot.Foundation.HANDLE);
				winmdroot.Foundation.NTSTATUS __result = PInvoke.NtSetInformationThread(ThreadHandleLocal, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
				return __result;
			}
			finally
			{
				if (ThreadHandleAddRef)
					ThreadHandle.DangerousRelease();
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtSetInformationThread(winmdroot.Foundation.HANDLE ThreadHandle, winmdroot.System.Threading.THREADINFOCLASS ThreadInformationClass, void* ThreadInformation, uint ThreadInformationLength);

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern nuint RtlGetReturnAddressHijackTarget();

		/// <inheritdoc cref="RtlRaiseCustomSystemEventTrigger(winmdroot.System.WindowsProgramming.CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG*)"/>
		internal static unsafe uint RtlRaiseCustomSystemEventTrigger(in winmdroot.System.WindowsProgramming.CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
		{
			fixed (winmdroot.System.WindowsProgramming.CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG* TriggerConfigLocal = &TriggerConfig)
			{
				uint __result = PInvoke.RtlRaiseCustomSystemEventTrigger(TriggerConfigLocal);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlRaiseCustomSystemEventTrigger(winmdroot.System.WindowsProgramming.CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG* TriggerConfig);

		/// <inheritdoc cref="NtClose(winmdroot.Foundation.HANDLE)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS NtClose(SafeHandle Handle)
		{
			bool HandleAddRef = false;
			try
			{
				winmdroot.Foundation.HANDLE HandleLocal;
				if (Handle is object)
				{
					Handle.DangerousAddRef(ref HandleAddRef);
					HandleLocal = (winmdroot.Foundation.HANDLE)Handle.DangerousGetHandle();
				}
				else
					HandleLocal = default(winmdroot.Foundation.HANDLE);
				winmdroot.Foundation.NTSTATUS __result = PInvoke.NtClose(HandleLocal);
				return __result;
			}
			finally
			{
				if (HandleAddRef)
					Handle.DangerousRelease();
			}
		}

		/// <summary>Deprecated. Closes the specified handle. NtClose is superseded by CloseHandle.</summary>
		/// <param name="Handle">The handle being closed.</param>
		/// <returns>
		/// <para>The various NTSTATUS values are defined in NTSTATUS.H, which is distributed with the Windows DDK. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntclose">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern winmdroot.Foundation.NTSTATUS NtClose(winmdroot.Foundation.HANDLE Handle);

		/// <inheritdoc cref="NtOpenFile(winmdroot.Foundation.HANDLE*, uint, winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES*, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK*, uint, uint)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtOpenFile(ref winmdroot.Foundation.HANDLE FileHandle, uint DesiredAccess, ref winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES ObjectAttributes, ref winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK IoStatusBlock, uint ShareAccess, uint OpenOptions)
		{
			fixed (winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlockLocal = &IoStatusBlock)
			{
				fixed (winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES* ObjectAttributesLocal = &ObjectAttributes)
				{
					fixed (winmdroot.Foundation.HANDLE* FileHandleLocal = &FileHandle)
					{
						winmdroot.Foundation.NTSTATUS __result = PInvoke.NtOpenFile(FileHandleLocal, DesiredAccess, ObjectAttributesLocal, IoStatusBlockLocal, ShareAccess, OpenOptions);
						return __result;
					}
				}
			}
		}

		/// <summary>Opens an existing file, device, directory, or volume, and returns a handle for the file object.</summary>
		/// <param name="FileHandle">
		/// <para>A pointer to a handle for the opened file. The driver must close the handle with <b>ZwClose</b> once the handle is no longer in use.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="DesiredAccess">
		/// <para>The <b>ACCESS_MASK</b> value that expresses the types of file access desired by the caller. For information about the types of access that can be specified, see <b>ZwCreateFile</b> in the WDK.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="ObjectAttributes">
		/// <para>A pointer to a structure that a caller initializes with <b>InitializeObjectAttributes</b>. If the caller is not running in the system process context, it must set the <b>OBJ_KERNEL_HANDLE</b> attribute for <i>ObjectAttributes</i>. For more information about specifying object attributes, see <b>ZwCreateFile</b> in the WDK.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="IoStatusBlock">
		/// <para>A pointer to a structure that contains information about the requested operation and the final completion status.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="ShareAccess">
		/// <para>The type of share access for the file. For more information, see <b>ZwCreateFile</b> in the WDK.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="OpenOptions">
		/// <para>The options to be applied when opening the file. For more information, see <b>ZwCreateFile</b> in the WDK.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para><b>NtOpenFile</b> either returns <b>STATUS_SUCCESS</b> or an appropriate error status. If it returns an error status, the caller can find additional information about the cause of the failure by checking the <i>IoStatusBlock</i>.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntopenfile">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtOpenFile(winmdroot.Foundation.HANDLE* FileHandle, uint DesiredAccess, winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES* ObjectAttributes, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlock, uint ShareAccess, uint OpenOptions);

		/// <inheritdoc cref="NtRenameKey(winmdroot.Foundation.HANDLE, winmdroot.Foundation.UNICODE_STRING*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtRenameKey(SafeHandle KeyHandle, in winmdroot.Foundation.UNICODE_STRING NewName)
		{
			bool KeyHandleAddRef = false;
			try
			{
				fixed (winmdroot.Foundation.UNICODE_STRING* NewNameLocal = &NewName)
				{
					winmdroot.Foundation.HANDLE KeyHandleLocal;
					if (KeyHandle is object)
					{
						KeyHandle.DangerousAddRef(ref KeyHandleAddRef);
						KeyHandleLocal = (winmdroot.Foundation.HANDLE)KeyHandle.DangerousGetHandle();
					}
					else
						KeyHandleLocal = default(winmdroot.Foundation.HANDLE);
					winmdroot.Foundation.NTSTATUS __result = PInvoke.NtRenameKey(KeyHandleLocal, NewNameLocal);
					return __result;
				}
			}
			finally
			{
				if (KeyHandleAddRef)
					KeyHandle.DangerousRelease();
			}
		}

		/// <summary>Changes the name of the specified registry key.</summary>
		/// <param name="KeyHandle">A handle to the key to be renamed. The handle must be opened with the KEY_WRITE access right.</param>
		/// <param name="NewName">A pointer to a UNICODE string that is the new name for the key.</param>
		/// <returns>
		/// <para>Returns an <b>NTSTATUS</b> or error code. An error code of <b>STATUS_ACCESS_DENIED</b> indicates that the caller does not have the necessary access rights to the specified registry key or subkeys. The forms and significance of <b>NTSTATUS</b> error codes are listed in the Ntstatus.h header file available in the WDK, and are described in the WDK documentation.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntrenamekey">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtRenameKey(winmdroot.Foundation.HANDLE KeyHandle, winmdroot.Foundation.UNICODE_STRING* NewName);

		/// <inheritdoc cref="NtNotifyChangeMultipleKeys(winmdroot.Foundation.HANDLE, uint, winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES*, winmdroot.Foundation.HANDLE, winmdroot.System.WindowsProgramming.PIO_APC_ROUTINE, void*, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK*, uint, winmdroot.Foundation.BOOLEAN, void*, uint, winmdroot.Foundation.BOOLEAN)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtNotifyChangeMultipleKeys(SafeHandle MasterKeyHandle, Span<winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES> SubordinateObjects, SafeHandle Event, winmdroot.System.WindowsProgramming.PIO_APC_ROUTINE ApcRoutine, void* ApcContext, out winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK IoStatusBlock, uint CompletionFilter, winmdroot.Foundation.BOOLEAN WatchTree, void* Buffer, uint BufferSize, winmdroot.Foundation.BOOLEAN Asynchronous)
		{
			bool MasterKeyHandleAddRef = false;
			bool EventAddRef = false;
			try
			{
				fixed (winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlockLocal = &IoStatusBlock)
				{
					fixed (winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES* SubordinateObjectsLocal = SubordinateObjects)
					{
						winmdroot.Foundation.HANDLE MasterKeyHandleLocal;
						if (MasterKeyHandle is object)
						{
							MasterKeyHandle.DangerousAddRef(ref MasterKeyHandleAddRef);
							MasterKeyHandleLocal = (winmdroot.Foundation.HANDLE)MasterKeyHandle.DangerousGetHandle();
						}
						else
							MasterKeyHandleLocal = default(winmdroot.Foundation.HANDLE);
						winmdroot.Foundation.HANDLE EventLocal;
						if (Event is object)
						{
							Event.DangerousAddRef(ref EventAddRef);
							EventLocal = (winmdroot.Foundation.HANDLE)Event.DangerousGetHandle();
						}
						else
							EventLocal = default(winmdroot.Foundation.HANDLE);
						winmdroot.Foundation.NTSTATUS __result = PInvoke.NtNotifyChangeMultipleKeys(MasterKeyHandleLocal, (uint )SubordinateObjects.Length, SubordinateObjectsLocal, EventLocal, ApcRoutine, ApcContext, IoStatusBlockLocal, CompletionFilter, WatchTree, Buffer, BufferSize, Asynchronous);
						return __result;
					}
				}
			}
			finally
			{
				if (MasterKeyHandleAddRef)
					MasterKeyHandle.DangerousRelease();
				if (EventAddRef)
					Event.DangerousRelease();
			}
		}

		/// <summary>Requests notification when a registry key or any of its subkeys changes.</summary>
		/// <param name="MasterKeyHandle">A handle to an open key. The handle must be opened with the <b>KEY_NOTIFY</b> access right.</param>
		/// <param name="Count">The number of subkeys under the key specified by the <i>MasterKeyHandle</i> parameter. This parameter must be 1.</param>
		/// <param name="SubordinateObjects">Pointer to an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wudfwdm/ns-wudfwdm-_object_attributes">OBJECT_ATTRIBUTES</a> structures, one for each subkey.   This array can contain one <b>OBJECT_ATTRIBUTES</b> structure.</param>
		/// <param name="Event">A handle to an event created by the caller. If <i>Event</i> is not <b>NULL</b>, the caller waits until the operation succeeds, at which time the event is signaled.</param>
		/// <param name="ApcRoutine">A pointer to an asynchronous procedure call (APC) function supplied by the caller. If <i>ApcRoutine</i> is not <b>NULL</b>, the specified APC function executes after the operation completes.</param>
		/// <param name="ApcContext">A pointer to a context supplied by the caller for its APC function. This value is passed to the APC function when it is executed. The <i>Asynchronous</i> parameter must be <b>TRUE</b>. If <i>ApcContext</i> is specified, the <i>Event</i> parameter must be <b>NULL</b>.</param>
		/// <param name="IoStatusBlock">A pointer to an <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_io_status_block">IO_STATUS_BLOCK</a> structure that contains the final status and information about the operation. For successful calls that return data, the number of bytes written to the <i>Buffer</i> parameter is supplied in the <b>Information</b> member of the <b>IO_STATUS_BLOCK</b> structure.</param>
		/// <param name="CompletionFilter">
		/// <para>A bitmap of operations that trigger notification. This parameter can be one or more of the following flags. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntnotifychangemultiplekeys#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="WatchTree">If this parameter is <b>TRUE</b>, the caller is notified about changes to all subkeys of the specified key. If this parameter is <b>FALSE</b>, the caller is notified only about changes to the specified key.</param>
		/// <param name="Buffer">Reserved for system use. This parameter must be <b>NULL</b>.</param>
		/// <param name="BufferSize">Reserved for system use. This parameter must be zero.</param>
		/// <param name="Asynchronous">If this parameter is <b>TRUE</b>, the function returns immediately. If this parameter is <b>FALSE</b>, the function does not return until the specified event occurs.</param>
		/// <returns>
		/// <para>Returns an <b>NTSTATUS</b> or error code. If the <i>Asynchronous</i> parameter is <b>TRUE</b> and the specified event has not yet occurred, the function returns <b>STATUS_PENDING</b>. The forms and significance of <b>NTSTATUS</b> error codes are listed in the Ntstatus.h header file available in the WDK, and are described in the WDK documentation.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntnotifychangemultiplekeys">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtNotifyChangeMultipleKeys(winmdroot.Foundation.HANDLE MasterKeyHandle, uint Count, [Optional] winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES* SubordinateObjects, winmdroot.Foundation.HANDLE Event, winmdroot.System.WindowsProgramming.PIO_APC_ROUTINE ApcRoutine, [Optional] void* ApcContext, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlock, uint CompletionFilter, winmdroot.Foundation.BOOLEAN WatchTree, [Optional] void* Buffer, uint BufferSize, winmdroot.Foundation.BOOLEAN Asynchronous);

		/// <inheritdoc cref="NtQueryMultipleValueKey(winmdroot.Foundation.HANDLE, winmdroot.System.WindowsProgramming.KEY_VALUE_ENTRY*, uint, void*, uint*, uint*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtQueryMultipleValueKey(SafeHandle KeyHandle, Span<winmdroot.System.WindowsProgramming.KEY_VALUE_ENTRY> ValueEntries, void* ValueBuffer, ref uint BufferLength, uint* RequiredBufferLength)
		{
			bool KeyHandleAddRef = false;
			try
			{
				fixed (uint* BufferLengthLocal = &BufferLength)
				{
					fixed (winmdroot.System.WindowsProgramming.KEY_VALUE_ENTRY* ValueEntriesLocal = ValueEntries)
					{
						winmdroot.Foundation.HANDLE KeyHandleLocal;
						if (KeyHandle is object)
						{
							KeyHandle.DangerousAddRef(ref KeyHandleAddRef);
							KeyHandleLocal = (winmdroot.Foundation.HANDLE)KeyHandle.DangerousGetHandle();
						}
						else
							KeyHandleLocal = default(winmdroot.Foundation.HANDLE);
						winmdroot.Foundation.NTSTATUS __result = PInvoke.NtQueryMultipleValueKey(KeyHandleLocal, ValueEntriesLocal, (uint )ValueEntries.Length, ValueBuffer, BufferLengthLocal, RequiredBufferLength);
						return __result;
					}
				}
			}
			finally
			{
				if (KeyHandleAddRef)
					KeyHandle.DangerousRelease();
			}
		}

		/// <summary>Retrieves values for the specified multiple-value key.</summary>
		/// <param name="KeyHandle">A handle to the key for which to retrieve values. The handle must be opened with the <b>KEY_QUERY_VALUE</b> access right.</param>
		/// <param name="ValueEntries">A pointer to an array of [**KEY_VALUE_ENTRY**] structures containing the names of values to retrieve.</param>
		/// <param name="EntryCount">The number of elements in the <i>ValueEntries</i> array.</param>
		/// <param name="ValueBuffer">A pointer to a buffer to receive the values.</param>
		/// <param name="BufferLength">A pointer to a variable that contains the size of the buffer at <i>ValueBuffer</i>, in bytes. When the function returns, the <i>BufferLength</i> parameter contains the number of bytes written to the buffer at <i>ValueBuffer</i>.</param>
		/// <param name="RequiredBufferLength">A pointer to a variable to receive the number of bytes required for all of the values to be returned by the function. This parameter can be <b>NULL</b>.</param>
		/// <returns>
		/// <para>Returns an <b>NTSTATUS</b> or error code. If the buffer is too small to hold the information to be retrieved, the function returns <b>STATUS_BUFFER_OVERFLOW</b> and, if the <i>RequiredBufferLength</i> parameter is specified, sets it to the buffer size required. The forms and significance of <b>NTSTATUS</b> error codes are listed in the Ntstatus.h header file available in the WDK, and are described in the WDK documentation.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntquerymultiplevaluekey">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtQueryMultipleValueKey(winmdroot.Foundation.HANDLE KeyHandle, winmdroot.System.WindowsProgramming.KEY_VALUE_ENTRY* ValueEntries, uint EntryCount, void* ValueBuffer, uint* BufferLength, [Optional] uint* RequiredBufferLength);

		/// <inheritdoc cref="NtSetInformationKey(winmdroot.Foundation.HANDLE, winmdroot.System.WindowsProgramming.KEY_SET_INFORMATION_CLASS, void*, uint)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtSetInformationKey(SafeHandle KeyHandle, winmdroot.System.WindowsProgramming.KEY_SET_INFORMATION_CLASS KeySetInformationClass, void* KeySetInformation, uint KeySetInformationLength)
		{
			bool KeyHandleAddRef = false;
			try
			{
				winmdroot.Foundation.HANDLE KeyHandleLocal;
				if (KeyHandle is object)
				{
					KeyHandle.DangerousAddRef(ref KeyHandleAddRef);
					KeyHandleLocal = (winmdroot.Foundation.HANDLE)KeyHandle.DangerousGetHandle();
				}
				else
					KeyHandleLocal = default(winmdroot.Foundation.HANDLE);
				winmdroot.Foundation.NTSTATUS __result = PInvoke.NtSetInformationKey(KeyHandleLocal, KeySetInformationClass, KeySetInformation, KeySetInformationLength);
				return __result;
			}
			finally
			{
				if (KeyHandleAddRef)
					KeyHandle.DangerousRelease();
			}
		}

		/// <summary>Sets information for the specified registry key.</summary>
		/// <param name="KeyHandle">
		/// <para>A handle to the registry key. The handle must be opened with the <b>KEY_WRITE</b> access right.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntsetinformationkey#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="KeySetInformationClass">
		/// <para>A <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ne-wdm-_key_set_information_class">KEY_SET_INFORMATION_CLASS</a> value that specifies the kind of information to be set.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntsetinformationkey#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="KeySetInformation">
		/// <para>A pointer to the buffer that contains the information to be set. The format of this buffer is determined by the <i>KeySetInformationClass</i> parameter.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntsetinformationkey#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="KeySetInformationLength">
		/// <para>The length of the buffer specified by the <i>KeySetInformation</i> parameter, in bytes.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntsetinformationkey#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Returns an <b>NTSTATUS</b> or error code. An error code of <b>STATUS_INFO_LENGTH_MISMATCH</b> indicates that the <i>KeySetInformationLength</i> parameter is the wrong length for the information class specified by the <i>KeySetInformationClass</i> parameter. The forms and significance of <b>NTSTATUS</b> error codes are listed in the Ntstatus.h header file available in the WDK, and are described in the WDK documentation.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntsetinformationkey">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtSetInformationKey(winmdroot.Foundation.HANDLE KeyHandle, winmdroot.System.WindowsProgramming.KEY_SET_INFORMATION_CLASS KeySetInformationClass, void* KeySetInformation, uint KeySetInformationLength);

		/// <inheritdoc cref="NtDeviceIoControlFile(winmdroot.Foundation.HANDLE, winmdroot.Foundation.HANDLE, winmdroot.System.WindowsProgramming.PIO_APC_ROUTINE, void*, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK*, uint, void*, uint, void*, uint)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS NtDeviceIoControlFile(SafeHandle FileHandle, SafeHandle Event, winmdroot.System.WindowsProgramming.PIO_APC_ROUTINE ApcRoutine, void* ApcContext, ref winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK IoStatusBlock, uint IoControlCode, void* InputBuffer, uint InputBufferLength, void* OutputBuffer, uint OutputBufferLength)
		{
			bool FileHandleAddRef = false;
			bool EventAddRef = false;
			try
			{
				fixed (winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlockLocal = &IoStatusBlock)
				{
					winmdroot.Foundation.HANDLE FileHandleLocal;
					if (FileHandle is object)
					{
						FileHandle.DangerousAddRef(ref FileHandleAddRef);
						FileHandleLocal = (winmdroot.Foundation.HANDLE)FileHandle.DangerousGetHandle();
					}
					else
						FileHandleLocal = default(winmdroot.Foundation.HANDLE);
					winmdroot.Foundation.HANDLE EventLocal;
					if (Event is object)
					{
						Event.DangerousAddRef(ref EventAddRef);
						EventLocal = (winmdroot.Foundation.HANDLE)Event.DangerousGetHandle();
					}
					else
						EventLocal = default(winmdroot.Foundation.HANDLE);
					winmdroot.Foundation.NTSTATUS __result = PInvoke.NtDeviceIoControlFile(FileHandleLocal, EventLocal, ApcRoutine, ApcContext, IoStatusBlockLocal, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
					return __result;
				}
			}
			finally
			{
				if (FileHandleAddRef)
					FileHandle.DangerousRelease();
				if (EventAddRef)
					Event.DangerousRelease();
			}
		}

		/// <summary>Deprecated. Builds descriptors for the supplied buffer(s) and passes the untyped data to the device driver associated with the file handle. NtDeviceIoControlFile is superseded by DeviceIoControl.</summary>
		/// <param name="FileHandle">Open file handle to the file or device to which the control information should be given.</param>
		/// <param name="Event">A handle to an event to be set to the <c>signaled</c> state when the operation completes. This parameter can be <b>NULL</b>.</param>
		/// <param name="ApcRoutine">Procedure to be invoked once the operation completes. This parameter can be <b>NULL</b>. For more information on Asynchronous Procedure Calls (APCs), see <a href="https://docs.microsoft.com/windows/desktop/Sync/asynchronous-procedure-calls">Asynchronous Procedure Calls</a>.</param>
		/// <param name="ApcContext">A pointer to pass to <i>ApcRoutine</i> when the operation completes. This parameter is required if an <i>ApcRoutine</i> is specified.</param>
		/// <param name="IoStatusBlock">Variable to receive the final completion status and information about the operation. Service calls that return information return the length of the data that is written to the output buffer in the Information field of this variable.</param>
		/// <param name="IoControlCode">Code that indicates which device I/O control function is to be executed.</param>
		/// <param name="InputBuffer">A pointer to a buffer that contains the information to be given to the target device. This parameter can be <b>NULL</b>. This information is device-dependent.</param>
		/// <param name="InputBufferLength">Length of the <i>InputBuffer</i> in bytes. If the buffer is not supplied, then this value is ignored.</param>
		/// <param name="OutputBuffer">A pointer to a buffer that is to receive the device-dependent return information from the target device. This parameter can be <b>NULL</b>.</param>
		/// <param name="OutputBufferLength">Length of the <i>OutputBuffer</i> in bytes. If the buffer is not supplied, then this value is ignored.</param>
		/// <returns>
		/// <para>The various NTSTATUS values are defined in NTSTATUS.H, which is distributed with the Windows DDK. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntdeviceiocontrolfile">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtDeviceIoControlFile(winmdroot.Foundation.HANDLE FileHandle, winmdroot.Foundation.HANDLE Event, winmdroot.System.WindowsProgramming.PIO_APC_ROUTINE ApcRoutine, void* ApcContext, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlock, uint IoControlCode, void* InputBuffer, uint InputBufferLength, void* OutputBuffer, uint OutputBufferLength);

		/// <inheritdoc cref="NtWaitForSingleObject(winmdroot.Foundation.HANDLE, winmdroot.Foundation.BOOLEAN, long*)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS NtWaitForSingleObject(SafeHandle Handle, winmdroot.Foundation.BOOLEAN Alertable, ref long Timeout)
		{
			bool HandleAddRef = false;
			try
			{
				fixed (long* TimeoutLocal = &Timeout)
				{
					winmdroot.Foundation.HANDLE HandleLocal;
					if (Handle is object)
					{
						Handle.DangerousAddRef(ref HandleAddRef);
						HandleLocal = (winmdroot.Foundation.HANDLE)Handle.DangerousGetHandle();
					}
					else
						HandleLocal = default(winmdroot.Foundation.HANDLE);
					winmdroot.Foundation.NTSTATUS __result = PInvoke.NtWaitForSingleObject(HandleLocal, Alertable, TimeoutLocal);
					return __result;
				}
			}
			finally
			{
				if (HandleAddRef)
					Handle.DangerousRelease();
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtWaitForSingleObject(winmdroot.Foundation.HANDLE Handle, winmdroot.Foundation.BOOLEAN Alertable, long* Timeout);

		/// <inheritdoc cref="RtlIsNameLegalDOS8Dot3(winmdroot.Foundation.UNICODE_STRING*, winmdroot.System.Kernel.STRING*, winmdroot.Foundation.BOOLEAN*)"/>
		internal static unsafe winmdroot.Foundation.BOOLEAN RtlIsNameLegalDOS8Dot3(ref winmdroot.Foundation.UNICODE_STRING Name, ref winmdroot.System.Kernel.STRING OemName, ref winmdroot.Foundation.BOOLEAN NameContainsSpaces)
		{
			fixed (winmdroot.Foundation.BOOLEAN* NameContainsSpacesLocal = &NameContainsSpaces)
			{
				fixed (winmdroot.System.Kernel.STRING* OemNameLocal = &OemName)
				{
					fixed (winmdroot.Foundation.UNICODE_STRING* NameLocal = &Name)
					{
						winmdroot.Foundation.BOOLEAN __result = PInvoke.RtlIsNameLegalDOS8Dot3(NameLocal, OemNameLocal, NameContainsSpacesLocal);
						return __result;
					}
				}
			}
		}

		/// <summary>Determines whether or not a specified name can be used to create a file on the FAT file system.</summary>
		/// <param name="Name">The file name, in 8.3 format.</param>
		/// <param name="OemName">
		/// <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlisnamelegaldos8dot3#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="NameContainsSpaces">
		/// <para>If the function returns <b>TRUE</b>, this parameter indicates whether or not the name contains spaces. If the function returns <b>FALSE</b>, this parameter is undefined.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlisnamelegaldos8dot3#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the specified name forms a valid 8.3 FAT file system name in the current OEM code page, the function returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b>.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlisnamelegaldos8dot3">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOLEAN RtlIsNameLegalDOS8Dot3(winmdroot.Foundation.UNICODE_STRING* Name, winmdroot.System.Kernel.STRING* OemName, winmdroot.Foundation.BOOLEAN* NameContainsSpaces);

		/// <inheritdoc cref="NtQueryObject(winmdroot.Foundation.HANDLE, winmdroot.System.WindowsProgramming.OBJECT_INFORMATION_CLASS, void*, uint, uint*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtQueryObject(SafeHandle Handle, winmdroot.System.WindowsProgramming.OBJECT_INFORMATION_CLASS ObjectInformationClass, void* ObjectInformation, uint ObjectInformationLength, uint* ReturnLength)
		{
			bool HandleAddRef = false;
			try
			{
				winmdroot.Foundation.HANDLE HandleLocal;
				if (Handle is object)
				{
					Handle.DangerousAddRef(ref HandleAddRef);
					HandleLocal = (winmdroot.Foundation.HANDLE)Handle.DangerousGetHandle();
				}
				else
					HandleLocal = default(winmdroot.Foundation.HANDLE);
				winmdroot.Foundation.NTSTATUS __result = PInvoke.NtQueryObject(HandleLocal, ObjectInformationClass, ObjectInformation, ObjectInformationLength, ReturnLength);
				return __result;
			}
			finally
			{
				if (HandleAddRef)
					Handle.DangerousRelease();
			}
		}

		/// <summary>Retrieves various kinds of object information.</summary>
		/// <param name="Handle">The handle of the object for which information is being queried.</param>
		/// <param name="ObjectInformationClass"></param>
		/// <param name="ObjectInformation">An optional pointer to a buffer where the requested information is to be returned. The size and structure of this information varies depending on the value of the <i>ObjectInformationClass</i> parameter.</param>
		/// <param name="ObjectInformationLength">The size of the buffer pointed to by the <i>ObjectInformation</i> parameter, in bytes.</param>
		/// <param name="ReturnLength">An optional pointer to a location where the function writes the actual size of the information requested. If that size is less than or equal to the <i>ObjectInformationLength</i> parameter, the function copies the information into the <i>ObjectInformation</i> buffer; otherwise, it returns an NTSTATUS error code and returns in <i>ReturnLength</i> the size of the buffer required to receive the requested information.</param>
		/// <returns>
		/// <para>Returns an NTSTATUS or error code. The forms and significance of NTSTATUS error codes are listed in the Ntstatus.h header file available in the WDK, and are described in the WDK documentation.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntqueryobject">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtQueryObject(winmdroot.Foundation.HANDLE Handle, winmdroot.System.WindowsProgramming.OBJECT_INFORMATION_CLASS ObjectInformationClass, [Optional] void* ObjectInformation, uint ObjectInformationLength, [Optional] uint* ReturnLength);

		/// <inheritdoc cref="NtQuerySystemInformation(winmdroot.System.WindowsProgramming.SYSTEM_INFORMATION_CLASS, void*, uint, uint*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtQuerySystemInformation(winmdroot.System.WindowsProgramming.SYSTEM_INFORMATION_CLASS SystemInformationClass, void* SystemInformation, uint SystemInformationLength, ref uint ReturnLength)
		{
			fixed (uint* ReturnLengthLocal = &ReturnLength)
			{
				winmdroot.Foundation.NTSTATUS __result = PInvoke.NtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLengthLocal);
				return __result;
			}
		}

		/// <summary>Retrieves the specified system information.</summary>
		/// <param name="SystemInformationClass">
		/// <para>One of the values enumerated in SYSTEM_INFORMATION_CLASS, which indicate the kind of system information to be retrieved. These include the following values.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntquerysysteminformation#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="SystemInformation">
		/// <para>A pointer to a buffer that receives the requested information. The size and structure of this information varies depending on the value of the <i>SystemInformationClass</i> parameter:</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntquerysysteminformation#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="SystemInformationLength">The size of the buffer pointed to by the <i>SystemInformation</i>parameter, in bytes.</param>
		/// <param name="ReturnLength">
		/// <para>An optional pointer to a location where the function  writes the actual size of the information requested. If that size is less than or equal to the <i>SystemInformationLength</i> parameter, the function copies the information into the <i>SystemInformation</i> buffer; otherwise, it returns an NTSTATUS error code and returns in <i>ReturnLength</i> the size of buffer required to receive the requested information.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntquerysysteminformation#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>Returns an  NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are listed in the Ntstatus.h header file available in the DDK, and are described in the DDK documentation.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntquerysysteminformation">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtQuerySystemInformation(winmdroot.System.WindowsProgramming.SYSTEM_INFORMATION_CLASS SystemInformationClass, void* SystemInformation, uint SystemInformationLength, uint* ReturnLength);

		/// <inheritdoc cref="NtQuerySystemTime(long*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtQuerySystemTime(ref long SystemTime)
		{
			fixed (long* SystemTimeLocal = &SystemTime)
			{
				winmdroot.Foundation.NTSTATUS __result = PInvoke.NtQuerySystemTime(SystemTimeLocal);
				return __result;
			}
		}

		/// <summary>Retrieves the current system time.</summary>
		/// <param name="SystemTime">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure that receives the system time. This is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).</param>
		/// <returns>If the function succeeds, it returns STATUS_SUCCESS.  If it fails, it will return the appropriate status code, which will typically be STATUS_ACCESS_VIOLATION.</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntquerysystemtime">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtQuerySystemTime(long* SystemTime);

		/// <inheritdoc cref="NtQueryTimerResolution(uint*, uint*, uint*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtQueryTimerResolution(out uint MaximumTime, out uint MinimumTime, out uint CurrentTime)
		{
			fixed (uint* CurrentTimeLocal = &CurrentTime)
			{
				fixed (uint* MinimumTimeLocal = &MinimumTime)
				{
					fixed (uint* MaximumTimeLocal = &MaximumTime)
					{
						winmdroot.Foundation.NTSTATUS __result = PInvoke.NtQueryTimerResolution(MaximumTimeLocal, MinimumTimeLocal, CurrentTimeLocal);
						return __result;
					}
				}
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtQueryTimerResolution(uint* MaximumTime, uint* MinimumTime, uint* CurrentTime);

		/// <inheritdoc cref="RtlLocalTimeToSystemTime(long*, long*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlLocalTimeToSystemTime(ref long LocalTime, ref long SystemTime)
		{
			fixed (long* SystemTimeLocal = &SystemTime)
			{
				fixed (long* LocalTimeLocal = &LocalTime)
				{
					winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlLocalTimeToSystemTime(LocalTimeLocal, SystemTimeLocal);
					return __result;
				}
			}
		}

		/// <summary>Converts the specified local time to system time.</summary>
		/// <param name="LocalTime">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure that specifies the local time.</param>
		/// <param name="SystemTime">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure that receives the returned system time.</param>
		/// <returns>If the function succeeds, it returns STATUS_SUCCESS.  If it fails, it will return the appropriate status code.</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtllocaltimetosystemtime">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlLocalTimeToSystemTime(long* LocalTime, long* SystemTime);

		/// <inheritdoc cref="RtlTimeToSecondsSince1970(long*, uint*)"/>
		internal static unsafe winmdroot.Foundation.BOOLEAN RtlTimeToSecondsSince1970(ref long Time, ref uint ElapsedSeconds)
		{
			fixed (uint* ElapsedSecondsLocal = &ElapsedSeconds)
			{
				fixed (long* TimeLocal = &Time)
				{
					winmdroot.Foundation.BOOLEAN __result = PInvoke.RtlTimeToSecondsSince1970(TimeLocal, ElapsedSecondsLocal);
					return __result;
				}
			}
		}

		/// <summary>Converts the specified 64-bit system time to the number of seconds since the beginning of January 1, 1970.</summary>
		/// <param name="Time">A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure that specifies the system time. The valid years for this value are 1970 to  2105 inclusive.</param>
		/// <param name="ElapsedSeconds">A pointer to a variable that receives the number of seconds.</param>
		/// <returns>If the function succeeds, it returns <b>TRUE</b>. If it fails, it returns <b>FALSE</b>. Typically, this function will fail if the specified value of the  <i>Time</i> parameter is not within the valid timeframe specified in the parameter description.</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtltimetosecondssince1970">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOLEAN RtlTimeToSecondsSince1970(long* Time, uint* ElapsedSeconds);

		/// <inheritdoc cref="RtlFreeAnsiString(winmdroot.System.Kernel.STRING*)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe void RtlFreeAnsiString(ref winmdroot.System.Kernel.STRING AnsiString)
		{
			fixed (winmdroot.System.Kernel.STRING* AnsiStringLocal = &AnsiString)
			{
				PInvoke.RtlFreeAnsiString(AnsiStringLocal);
			}
		}

		/// <summary>Frees the string buffer allocated by RtlUnicodeStringToAnsiString.</summary>
		/// <param name="AnsiString">A pointer to an ANSI string whose buffer was previously allocated by <a href="https://docs.microsoft.com/windows/desktop/api/winternl/nf-winternl-rtlunicodestringtoansistring">RtlUnicodeStringToAnsiString</a>.</param>
		/// <remarks>
		/// <para>This routine does not release the Unicode string buffer passed to <a href="https://docs.microsoft.com/windows/desktop/api/winternl/nf-winternl-rtlunicodestringtoansistring">RtlUnicodeStringToAnsiString</a>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlfreeansistring#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe void RtlFreeAnsiString(winmdroot.System.Kernel.STRING* AnsiString);

		/// <inheritdoc cref="RtlFreeUnicodeString(winmdroot.Foundation.UNICODE_STRING*)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe void RtlFreeUnicodeString(ref winmdroot.Foundation.UNICODE_STRING UnicodeString)
		{
			fixed (winmdroot.Foundation.UNICODE_STRING* UnicodeStringLocal = &UnicodeString)
			{
				PInvoke.RtlFreeUnicodeString(UnicodeStringLocal);
			}
		}

		/// <summary>Frees the string buffer allocated by RtlAnsiStringToUnicodeString or by RtlUpcaseUnicodeString.</summary>
		/// <param name="UnicodeString">
		/// <para>A pointer to the Unicode string whose buffer was previously allocated by <a href="https://docs.microsoft.com/windows/desktop/api/winternl/nf-winternl-rtlansistringtounicodestring">RtlAnsiStringToUnicodeString</a>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlfreeunicodestring#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <remarks>
		/// <para>This routine does not release the ANSI string buffer passed to <a href="https://docs.microsoft.com/windows/desktop/api/winternl/nf-winternl-rtlansistringtounicodestring">RtlAnsiStringToUnicodeString</a> or <b>RtlUpcaseUnicodeString</b>.</para>
		/// <para>Because there is no import library for this function, you must use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlfreeunicodestring#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe void RtlFreeUnicodeString(winmdroot.Foundation.UNICODE_STRING* UnicodeString);

		/// <inheritdoc cref="RtlFreeOemString(winmdroot.System.Kernel.STRING*)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe void RtlFreeOemString(ref winmdroot.System.Kernel.STRING OemString)
		{
			fixed (winmdroot.System.Kernel.STRING* OemStringLocal = &OemString)
			{
				PInvoke.RtlFreeOemString(OemStringLocal);
			}
		}

		/// <summary>Frees the string buffer allocated by RtlUnicodeStringToOemString.</summary>
		/// <param name="OemString">
		/// <para>Address of the OEM string whose buffer was previously allocated by <a href="https://docs.microsoft.com/windows/desktop/api/winternl/nf-winternl-rtlunicodestringtooemstring">RtlUnicodeStringToOemString</a>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlfreeoemstring#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <remarks>
		/// <para>This routine releases the <b>Buffer</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winternl/ns-winternl-string">OEM_STRING</a> structure. The <b>Length</b> and <b>MaximumLength</b> members are not affected by this routine.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlfreeoemstring#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe void RtlFreeOemString(winmdroot.System.Kernel.STRING* OemString);

		/// <inheritdoc cref="RtlInitString(winmdroot.System.Kernel.STRING*, sbyte*)"/>
		internal static unsafe void RtlInitString(ref winmdroot.System.Kernel.STRING DestinationString, ref sbyte SourceString)
		{
			fixed (sbyte* SourceStringLocal = &SourceString)
			{
				fixed (winmdroot.System.Kernel.STRING* DestinationStringLocal = &DestinationString)
				{
					PInvoke.RtlInitString(DestinationStringLocal, SourceStringLocal);
				}
			}
		}

		/// <summary>Initializes a counted string.</summary>
		/// <param name="DestinationString">The counted string to be initialized. The <i>DestinationString</i> is initialized to point to the <i>SourceString</i>. The <b>Length</b> and <b>MaximumLength</b> fields of the <i>DestinationString</i> are initialized to the length of the <i>SourceString</i>.</param>
		/// <param name="SourceString">A pointer to a null-terminated string. If the <i>SourceString</i> is not specified, the <b>Length</b> and <b>MaximumLength</b> fields of the <i>DestinationString</i> are initialized to zero.</param>
		/// <remarks>
		/// <para><b>Security Warning:  </b>Do not allow the <i>SourceString</i> parameter size to exceed <b>MAX_USHORT</b> characters. Because there is no import library for this function, you must use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.</para>
		/// <para><div class="alert"><b>Note</b>  <b>RtlInitString</b> is available in Windows XP. It might be altered or unavailable in subsequent versions.</div> <div> </div></para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlinitstring#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe void RtlInitString(winmdroot.System.Kernel.STRING* DestinationString, sbyte* SourceString);

		/// <inheritdoc cref="RtlInitStringEx(winmdroot.System.Kernel.STRING*, sbyte*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlInitStringEx(ref winmdroot.System.Kernel.STRING DestinationString, ref sbyte SourceString)
		{
			fixed (sbyte* SourceStringLocal = &SourceString)
			{
				fixed (winmdroot.System.Kernel.STRING* DestinationStringLocal = &DestinationString)
				{
					winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlInitStringEx(DestinationStringLocal, SourceStringLocal);
					return __result;
				}
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlInitStringEx(winmdroot.System.Kernel.STRING* DestinationString, sbyte* SourceString);

		/// <inheritdoc cref="RtlInitAnsiString(winmdroot.System.Kernel.STRING*, sbyte*)"/>
		internal static unsafe void RtlInitAnsiString(ref winmdroot.System.Kernel.STRING DestinationString, ref sbyte SourceString)
		{
			fixed (sbyte* SourceStringLocal = &SourceString)
			{
				fixed (winmdroot.System.Kernel.STRING* DestinationStringLocal = &DestinationString)
				{
					PInvoke.RtlInitAnsiString(DestinationStringLocal, SourceStringLocal);
				}
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe void RtlInitAnsiString(winmdroot.System.Kernel.STRING* DestinationString, sbyte* SourceString);

		/// <inheritdoc cref="RtlInitAnsiStringEx(winmdroot.System.Kernel.STRING*, sbyte*)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlInitAnsiStringEx(ref winmdroot.System.Kernel.STRING DestinationString, ref sbyte SourceString)
		{
			fixed (sbyte* SourceStringLocal = &SourceString)
			{
				fixed (winmdroot.System.Kernel.STRING* DestinationStringLocal = &DestinationString)
				{
					winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlInitAnsiStringEx(DestinationStringLocal, SourceStringLocal);
					return __result;
				}
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlInitAnsiStringEx(winmdroot.System.Kernel.STRING* DestinationString, sbyte* SourceString);

		/// <inheritdoc cref="RtlInitUnicodeString(winmdroot.Foundation.UNICODE_STRING*, winmdroot.Foundation.PCWSTR)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe void RtlInitUnicodeString(ref winmdroot.Foundation.UNICODE_STRING DestinationString, string SourceString)
		{
			fixed (char* SourceStringLocal = SourceString)
			{
				fixed (winmdroot.Foundation.UNICODE_STRING* DestinationStringLocal = &DestinationString)
				{
					PInvoke.RtlInitUnicodeString(DestinationStringLocal, SourceStringLocal);
				}
			}
		}

		/// <summary>Initializes a counted Unicode string.</summary>
		/// <param name="DestinationString">The buffer for a counted Unicode string to be initialized. The length is initialized to zero if the <i>SourceString</i> is not specified.</param>
		/// <param name="SourceString">
		/// <para>Optional pointer to a null-terminated Unicode string with which to initialize the counted string.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlinitunicodestring#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlinitunicodestring">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe void RtlInitUnicodeString(winmdroot.Foundation.UNICODE_STRING* DestinationString, winmdroot.Foundation.PCWSTR SourceString);

		/// <inheritdoc cref="RtlAnsiStringToUnicodeString(winmdroot.Foundation.UNICODE_STRING*, winmdroot.System.Kernel.STRING*, winmdroot.Foundation.BOOLEAN)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlAnsiStringToUnicodeString(ref winmdroot.Foundation.UNICODE_STRING DestinationString, ref winmdroot.System.Kernel.STRING SourceString, winmdroot.Foundation.BOOLEAN AllocateDestinationString)
		{
			fixed (winmdroot.System.Kernel.STRING* SourceStringLocal = &SourceString)
			{
				fixed (winmdroot.Foundation.UNICODE_STRING* DestinationStringLocal = &DestinationString)
				{
					winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlAnsiStringToUnicodeString(DestinationStringLocal, SourceStringLocal, AllocateDestinationString);
					return __result;
				}
			}
		}

		/// <summary>Converts the specified ANSI source string into a Unicode string.</summary>
		/// <param name="DestinationString">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/subauth/ns-subauth-unicode_string">UNICODE_STRING</a> structure to hold the converted Unicode string. If <i>AllocateDestinationString</i> is <b>TRUE</b>, the routine allocates a new buffer to hold the string data, and updates the <b>Buffer</b> member of <i>DestinationString</i> to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.</param>
		/// <param name="SourceString">A pointer to the <b>ANSI_STRING</b> structure that contains the ANSI string to be converted to Unicode.</param>
		/// <param name="AllocateDestinationString">Controls allocation of buffer space for the destination string.</param>
		/// <returns>
		/// <para>The various NTSTATUS values are defined in NTSTATUS.H, which is distributed with the Windows DDK. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlansistringtounicodestring">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlAnsiStringToUnicodeString(winmdroot.Foundation.UNICODE_STRING* DestinationString, winmdroot.System.Kernel.STRING* SourceString, winmdroot.Foundation.BOOLEAN AllocateDestinationString);

		/// <inheritdoc cref="RtlUnicodeStringToAnsiString(winmdroot.System.Kernel.STRING*, winmdroot.Foundation.UNICODE_STRING*, winmdroot.Foundation.BOOLEAN)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlUnicodeStringToAnsiString(ref winmdroot.System.Kernel.STRING DestinationString, ref winmdroot.Foundation.UNICODE_STRING SourceString, winmdroot.Foundation.BOOLEAN AllocateDestinationString)
		{
			fixed (winmdroot.Foundation.UNICODE_STRING* SourceStringLocal = &SourceString)
			{
				fixed (winmdroot.System.Kernel.STRING* DestinationStringLocal = &DestinationString)
				{
					winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlUnicodeStringToAnsiString(DestinationStringLocal, SourceStringLocal, AllocateDestinationString);
					return __result;
				}
			}
		}

		/// <summary>Converts the specified Unicode source string into an ANSI string.</summary>
		/// <param name="DestinationString">A pointer to an <b>ANSI_STRING</b> structure to hold the converted ANSI string. If <i>AllocateDestinationString</i> is <b>TRUE</b>, the routine allocates a new buffer to hold the string data and updates the <b>Buffer</b> member of <i>DestinationString</i> to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.</param>
		/// <param name="SourceString">The <a href="https://docs.microsoft.com/windows/desktop/api/subauth/ns-subauth-unicode_string">UNICODE_STRING</a> structure that contains the source string to be converted to ANSI.</param>
		/// <param name="AllocateDestinationString">Controls allocation of the buffer space for the <i>DestinationString</i>.</param>
		/// <returns>
		/// <para>The various NTSTATUS values are defined in NTSTATUS.H, which is distributed with the DDK. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlunicodestringtoansistring">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlUnicodeStringToAnsiString(winmdroot.System.Kernel.STRING* DestinationString, winmdroot.Foundation.UNICODE_STRING* SourceString, winmdroot.Foundation.BOOLEAN AllocateDestinationString);

		/// <inheritdoc cref="RtlUnicodeStringToOemString(winmdroot.System.Kernel.STRING*, winmdroot.Foundation.UNICODE_STRING*, winmdroot.Foundation.BOOLEAN)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlUnicodeStringToOemString(ref winmdroot.System.Kernel.STRING DestinationString, ref winmdroot.Foundation.UNICODE_STRING SourceString, winmdroot.Foundation.BOOLEAN AllocateDestinationString)
		{
			fixed (winmdroot.Foundation.UNICODE_STRING* SourceStringLocal = &SourceString)
			{
				fixed (winmdroot.System.Kernel.STRING* DestinationStringLocal = &DestinationString)
				{
					winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlUnicodeStringToOemString(DestinationStringLocal, SourceStringLocal, AllocateDestinationString);
					return __result;
				}
			}
		}

		/// <summary>Converts the specified Unicode source string into an OEM string. The translation is done with respect to the OEM code page (OCP).</summary>
		/// <param name="DestinationString">A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winternl/ns-winternl-string">OEM_STRING</a> structure that is contains the OEM equivalent to the Unicode source string. The <b>MaximumLength</b> field is set if <i>AllocateDestinationString</i> is <b>TRUE</b>.</param>
		/// <param name="SourceString">
		/// <para>A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/subauth/ns-subauth-unicode_string">UNICODE_STRING</a> structure that is to be converted to OEM.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlunicodestringtooemstring#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="AllocateDestinationString">
		/// <para>Controls allocation of the buffer space for the destination string.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlunicodestringtooemstring#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>The various NTSTATUS values are defined in NTSTATUS.H, which is distributed with the Windows DDK. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlunicodestringtooemstring">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlUnicodeStringToOemString(winmdroot.System.Kernel.STRING* DestinationString, winmdroot.Foundation.UNICODE_STRING* SourceString, winmdroot.Foundation.BOOLEAN AllocateDestinationString);

		/// <inheritdoc cref="RtlUnicodeToMultiByteSize(uint*, winmdroot.Foundation.PWSTR, uint)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlUnicodeToMultiByteSize(out uint BytesInMultiByteString, winmdroot.Foundation.PWSTR UnicodeString, uint BytesInUnicodeString)
		{
			fixed (uint* BytesInMultiByteStringLocal = &BytesInMultiByteString)
			{
				winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlUnicodeToMultiByteSize(BytesInMultiByteStringLocal, UnicodeString, BytesInUnicodeString);
				return __result;
			}
		}

		/// <summary>Determines how many bytes are needed to represent a Unicode string as an ANSI string.</summary>
		/// <param name="BytesInMultiByteString">Returns the number of bytes for the ANSI equivalent of the Unicode string pointed to by <i>UnicodeString</i>. This number does not include the terminating <b>NULL</b> character.</param>
		/// <param name="UnicodeString">The Unicode source string for which the ANSI length is calculated.</param>
		/// <param name="BytesInUnicodeString">
		/// <para>The number of bytes in the string pointed to by <i>UnicodeString</i>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlunicodetomultibytesize#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para></para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlunicodetomultibytesize">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlUnicodeToMultiByteSize(uint* BytesInMultiByteString, winmdroot.Foundation.PWSTR UnicodeString, uint BytesInUnicodeString);

		/// <inheritdoc cref="RtlCharToInteger(sbyte*, uint, uint*)"/>
		[SupportedOSPlatform("windows5.0")]
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlCharToInteger(ref sbyte String, uint Base, ref uint Value)
		{
			fixed (uint* ValueLocal = &Value)
			{
				fixed (sbyte* StringLocal = &String)
				{
					winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlCharToInteger(StringLocal, Base, ValueLocal);
					return __result;
				}
			}
		}

		/// <summary>Converts a character string to an integer.</summary>
		/// <param name="String">
		/// <para>A pointer to the string to convert. The format of the string is as follows: [whitespace] [{+ | -}] [0 [{x | o | b}]] [digits]</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlchartointeger#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Base"><b>ULONG</b> that contains the number base to use for the conversion, such as base 10. Only base 2, 8, 10, and 16 are supported.</param>
		/// <param name="Value">A pointer to a <b>ULONG</b> that receives the integer that resulted from the conversion.</param>
		/// <returns>If the function succeeds, the function returns <b>STATUS_SUCCESS</b>.</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlchartointeger">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.0")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlCharToInteger(sbyte* String, uint Base, uint* Value);

		/// <inheritdoc cref="RtlUniform(uint*)"/>
		internal static unsafe uint RtlUniform(ref uint Seed)
		{
			fixed (uint* SeedLocal = &Seed)
			{
				uint __result = PInvoke.RtlUniform(SeedLocal);
				return __result;
			}
		}

		/// <summary>Generates a uniform random number using D.H. Lehmer's 1948 algorithm.</summary>
		/// <param name="Seed">The seed value.</param>
		/// <returns>The function returns a random number uniformly distributed over [0..MAXLONG].</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtluniform">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlUniform(uint* Seed);

		/// <inheritdoc cref="RtlInitializeCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR*, int, global::System.Guid*)"/>
		internal static unsafe uint RtlInitializeCorrelationVector(out winmdroot.System.CorrelationVector.CORRELATION_VECTOR CorrelationVector, int Version, global::System.Guid? Guid)
		{
			fixed (winmdroot.System.CorrelationVector.CORRELATION_VECTOR* CorrelationVectorLocal = &CorrelationVector)
			{
				global::System.Guid GuidLocal = Guid.HasValue ? Guid.Value : default(global::System.Guid);
				uint __result = PInvoke.RtlInitializeCorrelationVector(CorrelationVectorLocal, Version, Guid.HasValue ? &GuidLocal : null);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlInitializeCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR* CorrelationVector, int Version, [Optional] global::System.Guid* Guid);

		/// <inheritdoc cref="RtlIncrementCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR*)"/>
		internal static unsafe uint RtlIncrementCorrelationVector(ref winmdroot.System.CorrelationVector.CORRELATION_VECTOR CorrelationVector)
		{
			fixed (winmdroot.System.CorrelationVector.CORRELATION_VECTOR* CorrelationVectorLocal = &CorrelationVector)
			{
				uint __result = PInvoke.RtlIncrementCorrelationVector(CorrelationVectorLocal);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlIncrementCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR* CorrelationVector);

		/// <inheritdoc cref="RtlExtendCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR*)"/>
		internal static unsafe uint RtlExtendCorrelationVector(ref winmdroot.System.CorrelationVector.CORRELATION_VECTOR CorrelationVector)
		{
			fixed (winmdroot.System.CorrelationVector.CORRELATION_VECTOR* CorrelationVectorLocal = &CorrelationVector)
			{
				uint __result = PInvoke.RtlExtendCorrelationVector(CorrelationVectorLocal);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlExtendCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR* CorrelationVector);

		/// <inheritdoc cref="RtlValidateCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR*)"/>
		internal static unsafe uint RtlValidateCorrelationVector(in winmdroot.System.CorrelationVector.CORRELATION_VECTOR Vector)
		{
			fixed (winmdroot.System.CorrelationVector.CORRELATION_VECTOR* VectorLocal = &Vector)
			{
				uint __result = PInvoke.RtlValidateCorrelationVector(VectorLocal);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe uint RtlValidateCorrelationVector(winmdroot.System.CorrelationVector.CORRELATION_VECTOR* Vector);

		/// <inheritdoc cref="NtCreateFile(winmdroot.Foundation.HANDLE*, uint, winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES*, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK*, long*, uint, winmdroot.Storage.FileSystem.FILE_SHARE_MODE, winmdroot.Storage.FileSystem.NT_CREATE_FILE_DISPOSITION, uint, void*, uint)"/>
		internal static unsafe winmdroot.Foundation.NTSTATUS NtCreateFile(ref winmdroot.Foundation.HANDLE FileHandle, uint DesiredAccess, ref winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES ObjectAttributes, ref winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK IoStatusBlock, ref long AllocationSize, uint FileAttributes, winmdroot.Storage.FileSystem.FILE_SHARE_MODE ShareAccess, winmdroot.Storage.FileSystem.NT_CREATE_FILE_DISPOSITION CreateDisposition, uint CreateOptions, void* EaBuffer, uint EaLength)
		{
			fixed (long* AllocationSizeLocal = &AllocationSize)
			{
				fixed (winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlockLocal = &IoStatusBlock)
				{
					fixed (winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES* ObjectAttributesLocal = &ObjectAttributes)
					{
						fixed (winmdroot.Foundation.HANDLE* FileHandleLocal = &FileHandle)
						{
							winmdroot.Foundation.NTSTATUS __result = PInvoke.NtCreateFile(FileHandleLocal, DesiredAccess, ObjectAttributesLocal, IoStatusBlockLocal, AllocationSizeLocal, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);
							return __result;
						}
					}
				}
			}
		}

		/// <summary>Creates a new file or directory, or opens an existing file, device, directory, or volume.</summary>
		/// <param name="FileHandle">A pointer to a variable that receives the file handle if the call is successful.</param>
		/// <param name="DesiredAccess">
		/// <para>The <b>ACCESS_MASK</b> value that expresses the type of access that the caller requires to the file or directory. The set of system-defined <i>DesiredAccess</i> flags determines the following specific access rights for file objects. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="ObjectAttributes">
		/// <para>A pointer to a structure already initialized with <b>InitializeObjectAttributes</b>. Members of this structure for a file object include the following. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="IoStatusBlock">
		/// <para>A pointer to a variable that receives the final completion status and information about the requested operation. On return from <b>NtCreateFile</b>, the</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="AllocationSize">
		/// <para>The initial allocation size in bytes for the file. A nonzero value has no effect unless the file is being created, overwritten, or superseded.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="FileAttributes">
		/// <para>The file attributes. Explicitly specified attributes are applied only when the file is created, superseded, or, in some cases, overwritten. By default, this value is a <b>FILE_ATTRIBUTE_NORMAL</b>, which can be overridden by an ORed combination of one or more <b>FILE_ATTRIBUTE_</b><i>xxxx</i> flags, which are defined in Wdm.h and NtDdk.h. For a list of flags that can be used with <b>NtCreateFile</b>, see <b>CreateFile</b>.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="ShareAccess">The type of share access that the caller would like to use in  the file, as zero, or as one or a</param>
		/// <param name="CreateDisposition"></param>
		/// <param name="CreateOptions">
		/// <para>The options to be applied when creating or opening the file, as a compatible combination of the following flags. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="EaBuffer">
		/// <para>Pointer to an EA buffer used to pass extended attributes.</para>
		/// <para><div class="alert"><b>Note</b>  Some file systems may not support EA buffers.</div> <div> </div></para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="EaLength">Length of the EA buffer.</param>
		/// <returns>
		/// <para><b>NtCreateFile</b> returns either <b>STATUS_SUCCESS</b> or an appropriate error status. If it returns an error status, the caller can find more information about the cause of the failure by checking the <i>IoStatusBlock</i>. To simplify this check, an application can use the <b>NT_SUCCESS</b>, <b>NT_ERROR</b>, and <b>NT_WARNING</b> macros.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-ntcreatefile">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS NtCreateFile(winmdroot.Foundation.HANDLE* FileHandle, uint DesiredAccess, winmdroot.System.WindowsProgramming.OBJECT_ATTRIBUTES* ObjectAttributes, winmdroot.System.WindowsProgramming.IO_STATUS_BLOCK* IoStatusBlock, long* AllocationSize, uint FileAttributes, winmdroot.Storage.FileSystem.FILE_SHARE_MODE ShareAccess, winmdroot.Storage.FileSystem.NT_CREATE_FILE_DISPOSITION CreateDisposition, uint CreateOptions, void* EaBuffer, uint EaLength);

		/// <summary>Converts the specified NTSTATUS code to its equivalent system error code.</summary>
		/// <param name="Status">The NTSTATUS code to be converted.</param>
		/// <returns>The function returns the corresponding <a href="/windows/desktop/Debug/system-error-codes">system error code</a>.</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlntstatustodoserror">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.1.2600")]
		internal static extern uint RtlNtStatusToDosError(winmdroot.Foundation.NTSTATUS Status);

		/// <inheritdoc cref="RtlIpv4AddressToString(winmdroot.Networking.WinSock.IN_ADDR*, winmdroot.Foundation.PWSTR)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe winmdroot.Foundation.PWSTR RtlIpv4AddressToString(in winmdroot.Networking.WinSock.IN_ADDR Addr, winmdroot.Foundation.PWSTR S)
		{
			fixed (winmdroot.Networking.WinSock.IN_ADDR* AddrLocal = &Addr)
			{
				winmdroot.Foundation.PWSTR __result = PInvoke.RtlIpv4AddressToString(AddrLocal, S);
				return __result;
			}
		}

		/// <summary>Converts an IPv4 address to a string in Internet standard dotted-decimal format.</summary>
		/// <param name="Addr">The IPv4 address in network byte order.</param>
		/// <param name="S">A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv4 address. This buffer should be large enough to hold at least 16 characters.</param>
		/// <returns>
		/// <para>A pointer to the NULL character inserted at the end of the string representation of the IPv4 address. This can be used by the caller to easily append more information to the string.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4addresstostringw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv4AddressToStringW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe winmdroot.Foundation.PWSTR RtlIpv4AddressToString(winmdroot.Networking.WinSock.IN_ADDR* Addr, winmdroot.Foundation.PWSTR S);

		/// <inheritdoc cref="RtlIpv4AddressToStringEx(winmdroot.Networking.WinSock.IN_ADDR*, ushort, winmdroot.Foundation.PWSTR, uint*)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe int RtlIpv4AddressToStringEx(in winmdroot.Networking.WinSock.IN_ADDR Address, ushort Port, winmdroot.Foundation.PWSTR AddressString, ref uint AddressStringLength)
		{
			fixed (uint* AddressStringLengthLocal = &AddressStringLength)
			{
				fixed (winmdroot.Networking.WinSock.IN_ADDR* AddressLocal = &Address)
				{
					int __result = PInvoke.RtlIpv4AddressToStringEx(AddressLocal, Port, AddressString, AddressStringLengthLocal);
					return __result;
				}
			}
		}

		/// <summary>Converts an IPv4 address and port number to a string in Internet standard format.</summary>
		/// <param name="Address">The IPv4 address in network byte order.</param>
		/// <param name="Port">The port number in network byte order format. This parameter is optional.</param>
		/// <param name="AddressString">A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IPv4 address and port. This buffer should be large enough to hold at least INET_ADDRSTRLEN characters. The INET_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.</param>
		/// <param name="AddressStringLength">
		/// <para>On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator. On output, this parameter contains the number of characters actually written to the buffer pointed to by the <i>AddressString</i> parameter.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4addresstostringexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value is one of the following error codes. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4addresstostringexw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv4AddressToStringExW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe int RtlIpv4AddressToStringEx(winmdroot.Networking.WinSock.IN_ADDR* Address, ushort Port, winmdroot.Foundation.PWSTR AddressString, uint* AddressStringLength);

		/// <inheritdoc cref="RtlIpv4StringToAddress(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.BOOLEAN, winmdroot.Foundation.PWSTR*, winmdroot.Networking.WinSock.IN_ADDR*)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe int RtlIpv4StringToAddress(string S, winmdroot.Foundation.BOOLEAN Strict, out winmdroot.Foundation.PWSTR Terminator, out winmdroot.Networking.WinSock.IN_ADDR Addr)
		{
			fixed (winmdroot.Networking.WinSock.IN_ADDR* AddrLocal = &Addr)
			{
				fixed (winmdroot.Foundation.PWSTR* TerminatorLocal = &Terminator)
				{
					fixed (char* SLocal = S)
					{
						int __result = PInvoke.RtlIpv4StringToAddress(SLocal, Strict, TerminatorLocal, AddrLocal);
						return __result;
					}
				}
			}
		}

		/// <summary>Converts a string representation of an IPv4 address to a binary IPv4 address.</summary>
		/// <param name="S">A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address.</param>
		/// <param name="Strict">
		/// <para>A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts. If this parameter is <b>FALSE</b>, any of four possible forms are allowed, with decimal, octal, or hexadecimal notation. See the Remarks section for details.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Terminator">
		/// <para>A parameter that receives a pointer to the character that terminated the converted string. This can be used by the caller to extract more information from the string.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Addr">A pointer where the binary representation of the IPv4 address is to be stored.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value is one of the following error codes. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv4StringToAddressW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe int RtlIpv4StringToAddress(winmdroot.Foundation.PCWSTR S, winmdroot.Foundation.BOOLEAN Strict, winmdroot.Foundation.PWSTR* Terminator, winmdroot.Networking.WinSock.IN_ADDR* Addr);

		/// <inheritdoc cref="RtlIpv4StringToAddressEx(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.BOOLEAN, winmdroot.Networking.WinSock.IN_ADDR*, ushort*)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe int RtlIpv4StringToAddressEx(string AddressString, winmdroot.Foundation.BOOLEAN Strict, out winmdroot.Networking.WinSock.IN_ADDR Address, out ushort Port)
		{
			fixed (ushort* PortLocal = &Port)
			{
				fixed (winmdroot.Networking.WinSock.IN_ADDR* AddressLocal = &Address)
				{
					fixed (char* AddressStringLocal = AddressString)
					{
						int __result = PInvoke.RtlIpv4StringToAddressEx(AddressStringLocal, Strict, AddressLocal, PortLocal);
						return __result;
					}
				}
			}
		}

		/// <summary>Converts a string representation of an IPv4 address and port number to a binary IPv4 address and port.</summary>
		/// <param name="AddressString">A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address followed by an optional colon and string representation of a port number.</param>
		/// <param name="Strict">
		/// <para>A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts. If this parameter is <b>FALSE</b>, any of four forms are allowed for the string representation of the Ipv4 address, with decimal, octal, or hexadecimal notation. See the Remarks section for details.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Address">A pointer where the binary representation of the IPv4 address is to be stored. The IPv4 address is stored in network byte order.</param>
		/// <param name="Port">A pointer where the binary representation of the port number is to be stored. The port number is returned in network byte order. If no port was specified in the string pointed to by the <i>AddressString</i> parameter, then the <i>Port</i> parameter is set to zero.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value is one of the following error codes. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressexw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv4StringToAddressExW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe int RtlIpv4StringToAddressEx(winmdroot.Foundation.PCWSTR AddressString, winmdroot.Foundation.BOOLEAN Strict, winmdroot.Networking.WinSock.IN_ADDR* Address, ushort* Port);

		/// <inheritdoc cref="RtlIpv6AddressToString(winmdroot.Networking.WinSock.IN6_ADDR*, winmdroot.Foundation.PWSTR)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe winmdroot.Foundation.PWSTR RtlIpv6AddressToString(in winmdroot.Networking.WinSock.IN6_ADDR Addr, winmdroot.Foundation.PWSTR S)
		{
			fixed (winmdroot.Networking.WinSock.IN6_ADDR* AddrLocal = &Addr)
			{
				winmdroot.Foundation.PWSTR __result = PInvoke.RtlIpv6AddressToString(AddrLocal, S);
				return __result;
			}
		}

		/// <summary>Converts an IPv6 address to a string in Internet standard format.</summary>
		/// <param name="Addr">The IPv6 address in network byte order.</param>
		/// <param name="S">A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv6 address. This buffer should be large enough to hold at least 46 characters.</param>
		/// <returns>
		/// <para>A pointer to the NULL character inserted at the end of the string representation of the IPv6 address. This can be used by the caller to easily append more information to the string.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6addresstostringw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv6AddressToStringW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe winmdroot.Foundation.PWSTR RtlIpv6AddressToString(winmdroot.Networking.WinSock.IN6_ADDR* Addr, winmdroot.Foundation.PWSTR S);

		/// <inheritdoc cref="RtlIpv6AddressToStringEx(winmdroot.Networking.WinSock.IN6_ADDR*, uint, ushort, winmdroot.Foundation.PWSTR, uint*)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe int RtlIpv6AddressToStringEx(in winmdroot.Networking.WinSock.IN6_ADDR Address, uint ScopeId, ushort Port, winmdroot.Foundation.PWSTR AddressString, ref uint AddressStringLength)
		{
			fixed (uint* AddressStringLengthLocal = &AddressStringLength)
			{
				fixed (winmdroot.Networking.WinSock.IN6_ADDR* AddressLocal = &Address)
				{
					int __result = PInvoke.RtlIpv6AddressToStringEx(AddressLocal, ScopeId, Port, AddressString, AddressStringLengthLocal);
					return __result;
				}
			}
		}

		/// <summary>Converts an IPv6 address, scope ID, and port number to a string.</summary>
		/// <param name="Address">The IPv6 address in network byte order.</param>
		/// <param name="ScopeId">The scope ID of the IPv6 address in network byte order. This parameter is optional.</param>
		/// <param name="Port">The port number in network byte order format. This parameter is optional.</param>
		/// <param name="AddressString">A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IP address, scope ID, and port. This buffer should be large enough to hold at least INET6_ADDRSTRLEN characters. The INET6_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.</param>
		/// <param name="AddressStringLength">
		/// <para>On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator. On output, this parameter contains the number of characters actually written to the buffer pointed to by the <i>AddressString</i> parameter.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6addresstostringexw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value is one of the following error codes. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6addresstostringexw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv6AddressToStringExW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe int RtlIpv6AddressToStringEx(winmdroot.Networking.WinSock.IN6_ADDR* Address, uint ScopeId, ushort Port, winmdroot.Foundation.PWSTR AddressString, uint* AddressStringLength);

		/// <inheritdoc cref="RtlIpv6StringToAddress(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PWSTR*, winmdroot.Networking.WinSock.IN6_ADDR*)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe int RtlIpv6StringToAddress(string S, out winmdroot.Foundation.PWSTR Terminator, out winmdroot.Networking.WinSock.IN6_ADDR Addr)
		{
			fixed (winmdroot.Networking.WinSock.IN6_ADDR* AddrLocal = &Addr)
			{
				fixed (winmdroot.Foundation.PWSTR* TerminatorLocal = &Terminator)
				{
					fixed (char* SLocal = S)
					{
						int __result = PInvoke.RtlIpv6StringToAddress(SLocal, TerminatorLocal, AddrLocal);
						return __result;
					}
				}
			}
		}

		/// <summary>Converts a string representation of an IPv6 address to a binary IPv6 address.</summary>
		/// <param name="S">A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address.</param>
		/// <param name="Terminator">
		/// <para>A parameter that receives a pointer to the character that terminated the converted string. This can be used by the caller to extract more information from the string.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6stringtoaddressw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Addr">A pointer where the binary representation of the IPv6 address is to be stored.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value is one of the following error codes. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6stringtoaddressw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv6StringToAddressW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe int RtlIpv6StringToAddress(winmdroot.Foundation.PCWSTR S, winmdroot.Foundation.PWSTR* Terminator, winmdroot.Networking.WinSock.IN6_ADDR* Addr);

		/// <inheritdoc cref="RtlIpv6StringToAddressEx(winmdroot.Foundation.PCWSTR, winmdroot.Networking.WinSock.IN6_ADDR*, uint*, ushort*)"/>
		[SupportedOSPlatform("windows6.0.6000")]
		internal static unsafe int RtlIpv6StringToAddressEx(string AddressString, out winmdroot.Networking.WinSock.IN6_ADDR Address, out uint ScopeId, out ushort Port)
		{
			fixed (ushort* PortLocal = &Port)
			{
				fixed (uint* ScopeIdLocal = &ScopeId)
				{
					fixed (winmdroot.Networking.WinSock.IN6_ADDR* AddressLocal = &Address)
					{
						fixed (char* AddressStringLocal = AddressString)
						{
							int __result = PInvoke.RtlIpv6StringToAddressEx(AddressStringLocal, AddressLocal, ScopeIdLocal, PortLocal);
							return __result;
						}
					}
				}
			}
		}

		/// <summary>Converts a string representation of an IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port.</summary>
		/// <param name="AddressString">A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address, scope ID, and port number.</param>
		/// <param name="Address">A pointer where the binary representation of the IPv6 address is to be stored.</param>
		/// <param name="ScopeId">A pointer to where scope ID of the IPv6 address is stored. If <i>AddressString</i> parameter does not contain the string representation of a scope ID, then zero is returned in this parameter.</param>
		/// <param name="Port">A pointer where the port number is stored. The port number is in network byte order format. If <i>AddressString</i> parameter does not contain the string representation of a port number, then zero is returned in this parameter.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value is one of the following error codes. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6stringtoaddressexw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlIpv6StringToAddressExW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.0.6000")]
		internal static extern unsafe int RtlIpv6StringToAddressEx(winmdroot.Foundation.PCWSTR AddressString, winmdroot.Networking.WinSock.IN6_ADDR* Address, uint* ScopeId, ushort* Port);

		/// <inheritdoc cref="RtlEthernetAddressToString(winmdroot.Networking.WinSock.DL_EUI48*, winmdroot.Foundation.PWSTR)"/>
		[SupportedOSPlatform("windows6.1")]
		internal static unsafe winmdroot.Foundation.PWSTR RtlEthernetAddressToString(in winmdroot.Networking.WinSock.DL_EUI48 Addr, winmdroot.Foundation.PWSTR S)
		{
			fixed (winmdroot.Networking.WinSock.DL_EUI48* AddrLocal = &Addr)
			{
				winmdroot.Foundation.PWSTR __result = PInvoke.RtlEthernetAddressToString(AddrLocal, S);
				return __result;
			}
		}

		/// <summary>Converts a binary Ethernet address to a string representation of the Ethernet MAC address.</summary>
		/// <param name="Addr">
		/// <para>The Ethernet address in binary format. The Ethernet address is in network order (bytes ordered from left to right).</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetaddresstostringw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="S">A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the Ethernet address. This buffer should be large enough to hold at least 18 characters.</param>
		/// <returns>
		/// <para>A pointer to the NULL character inserted at the end of the string representation of the Ethernet MAC address. This can be used by the caller to easily append more information to the string.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetaddresstostringw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlEthernetAddressToStringW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.1")]
		internal static extern unsafe winmdroot.Foundation.PWSTR RtlEthernetAddressToString(winmdroot.Networking.WinSock.DL_EUI48* Addr, winmdroot.Foundation.PWSTR S);

		/// <inheritdoc cref="RtlEthernetStringToAddress(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PWSTR*, winmdroot.Networking.WinSock.DL_EUI48*)"/>
		[SupportedOSPlatform("windows6.1")]
		internal static unsafe int RtlEthernetStringToAddress(string S, out winmdroot.Foundation.PWSTR Terminator, out winmdroot.Networking.WinSock.DL_EUI48 Addr)
		{
			fixed (winmdroot.Networking.WinSock.DL_EUI48* AddrLocal = &Addr)
			{
				fixed (winmdroot.Foundation.PWSTR* TerminatorLocal = &Terminator)
				{
					fixed (char* SLocal = S)
					{
						int __result = PInvoke.RtlEthernetStringToAddress(SLocal, TerminatorLocal, AddrLocal);
						return __result;
					}
				}
			}
		}

		/// <summary>Converts a string representation of an Ethernet MAC address to a binary format of the Ethernet address.</summary>
		/// <param name="S">A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the Ethernet MAC  address.</param>
		/// <param name="Terminator">
		/// <para>A parameter that receives a pointer to the character that terminated the converted string. This can be used by the caller to extract more information from the string.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetstringtoaddressw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="Addr">A pointer where the binary representation of the Ethernet MAC address is to be stored.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value is one of the following error codes. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetstringtoaddressw">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true, EntryPoint = "RtlEthernetStringToAddressW")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows6.1")]
		internal static extern unsafe int RtlEthernetStringToAddress(winmdroot.Foundation.PCWSTR S, winmdroot.Foundation.PWSTR* Terminator, winmdroot.Networking.WinSock.DL_EUI48* Addr);

		/// <inheritdoc cref="RtlNormalizeSecurityDescriptor(winmdroot.Security.PSECURITY_DESCRIPTOR*, uint, winmdroot.Security.PSECURITY_DESCRIPTOR*, uint*, winmdroot.Foundation.BOOLEAN)"/>
		internal static unsafe winmdroot.Foundation.BOOLEAN RtlNormalizeSecurityDescriptor(ref winmdroot.Security.PSECURITY_DESCRIPTOR SecurityDescriptor, uint SecurityDescriptorLength, winmdroot.Security.PSECURITY_DESCRIPTOR* NewSecurityDescriptor, uint* NewSecurityDescriptorLength, winmdroot.Foundation.BOOLEAN CheckOnly)
		{
			fixed (winmdroot.Security.PSECURITY_DESCRIPTOR* SecurityDescriptorLocal = &SecurityDescriptor)
			{
				winmdroot.Foundation.BOOLEAN __result = PInvoke.RtlNormalizeSecurityDescriptor(SecurityDescriptorLocal, SecurityDescriptorLength, NewSecurityDescriptor, NewSecurityDescriptorLength, CheckOnly);
				return __result;
			}
		}

		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern unsafe winmdroot.Foundation.BOOLEAN RtlNormalizeSecurityDescriptor(winmdroot.Security.PSECURITY_DESCRIPTOR* SecurityDescriptor, uint SecurityDescriptorLength, [Optional] winmdroot.Security.PSECURITY_DESCRIPTOR* NewSecurityDescriptor, [Optional] uint* NewSecurityDescriptorLength, winmdroot.Foundation.BOOLEAN CheckOnly);

		/// <inheritdoc cref="RtlConvertSidToUnicodeString(winmdroot.Foundation.UNICODE_STRING*, winmdroot.Foundation.PSID, winmdroot.Foundation.BOOLEAN)"/>
		[SupportedOSPlatform("windows5.1.2600")]
		internal static unsafe winmdroot.Foundation.NTSTATUS RtlConvertSidToUnicodeString(ref winmdroot.Foundation.UNICODE_STRING UnicodeString, winmdroot.Foundation.PSID Sid, winmdroot.Foundation.BOOLEAN AllocateDestinationString)
		{
			fixed (winmdroot.Foundation.UNICODE_STRING* UnicodeStringLocal = &UnicodeString)
			{
				winmdroot.Foundation.NTSTATUS __result = PInvoke.RtlConvertSidToUnicodeString(UnicodeStringLocal, Sid, AllocateDestinationString);
				return __result;
			}
		}

		/// <summary>Converts a security identifier (SID) to its Unicode character representation.</summary>
		/// <param name="UnicodeString">A pointer to the Unicode character representation of the security identifier.</param>
		/// <param name="Sid">A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-sid">SID</a> structure that represents the security identifier.</param>
		/// <param name="AllocateDestinationString">If <b>TRUE</b>, then  <i>UnicodeString</i> is allocated on behalf of the caller, and it is the caller's responsibility to free the allocated memory by calling the <b>RtlFreeUnicodeString</b> function. If <b>FALSE</b>, the caller is responsible for allocating and freeing  <i>UnicodeString</i>.</param>
		/// <returns>The return value is an  NTSTATUS code. A value of STATUS_SUCCESS (0x00000000L) is returned if the function succeeds.</returns>
		/// <remarks>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//winternl/nf-winternl-rtlconvertsidtounicodestring">Learn more about this API from docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ntdll.dll", ExactSpelling = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows5.1.2600")]
		internal static extern unsafe winmdroot.Foundation.NTSTATUS RtlConvertSidToUnicodeString(winmdroot.Foundation.UNICODE_STRING* UnicodeString, winmdroot.Foundation.PSID Sid, winmdroot.Foundation.BOOLEAN AllocateDestinationString);
	}
}
